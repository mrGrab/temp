'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var ExtendableError = _interopDefault(require('es6-error'));
var hoistStatics = _interopDefault(require('hoist-non-react-statics'));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);

  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
    return o.__proto__;
  };

  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

//  strict
var initialState = null;

var _React$createContext = React.createContext(initialState),
    Provider = _React$createContext.Provider,
    Consumer = _React$createContext.Consumer;

//  strict
// flowlint unclear-type:off
var formatErrorPath = function formatErrorPath(path, more) {
  return path.map(function (val) {
    return typeof val === 'string' ? "\"".concat(val, "\"") : "".concat(val);
  }).concat(more ? ['...'] : []).join(', ');
};

var pathError = function pathError() {
  return 'Invalid path. Expected array or string.';
};
var pathSyntaxError = function pathSyntaxError(path) {
  return "Invalid path. Syntax error at \"".concat(path, "\".");
};
var emptyPathError = function emptyPathError() {
  return 'Invalid path. Expected non-empty array or string.';
};
var emptyPathArrayError = function emptyPathArrayError() {
  return 'Invalid path. Expected non-empty array.';
};
var emptyPathStringError = function emptyPathStringError() {
  return 'Invalid path. Expected non-empty string.';
};
var arrayTargetError = function arrayTargetError() {
  return 'Invalid target. Expected array.';
};
var indexError = function indexError() {
  return 'Invalid index. Expected int.';
};
var boundsError = function boundsError() {
  return 'Invalid index. Out of bounds.';
};
var pathArrayError = function pathArrayError() {
  return 'Invalid path. Expected array.';
};
var expectedArrayError = function expectedArrayError(value, path, more) {
  return "Invalid value. Expected array at path: [ ".concat(formatErrorPath(path, more), " ]. Encountered value: ").concat(value, ".");
};
var expectedPathIntError = function expectedPathIntError(path, more) {
  return "Invalid path part. Expected int at path: [ ".concat(formatErrorPath(path, more), " ].");
};
var pathPartError = function pathPartError(path, more) {
  return "Invalid path part. Expected string or int at path: [ ".concat(formatErrorPath(path, more), " ].");
};
var isValidPath = function isValidPath(path) {
  return Array.isArray(path) && path.length !== 0 || typeof path === 'string' && path !== '';
};
var isInt = function isInt(val) {
  return typeof val === 'number' && val === (val | 0);
};
var insert = function insert(array, index, value) {
  if (!Array.isArray(array)) {
    throw new TypeError(arrayTargetError());
  }

  if (!isInt(index)) {
    throw new TypeError(indexError());
  }

  if (index < 0 || index > array.length) {
    throw new TypeError(boundsError());
  }

  return array.slice(0, index).concat([value], array.slice(index));
};
var remove = function remove(array, index) {
  if (!Array.isArray(array)) {
    throw new TypeError(arrayTargetError());
  }

  if (!isInt(index)) {
    throw new TypeError(indexError());
  }

  if (index < 0 || index >= array.length) {
    throw new TypeError(boundsError());
  }

  return array.slice(0, index).concat(array.slice(index + 1));
};
var equals = function equals(a, b) {
  if (a === b) {
    return true;
  } // eslint-disable-next-line no-self-compare


  if (a !== a && b !== b) {
    return true;
  }

  if (a instanceof Date && b instanceof Date && a.getTime() === b.getTime()) {
    return true;
  }

  return false;
};
var formatPath = function formatPath(path) {
  if (typeof path === 'string') {
    return path;
  }

  if (Array.isArray(path)) {
    var result = '';
    path.forEach(function (part) {
      if (isInt(part)) {
        result += "[".concat(part, "]");
      } else if (result) {
        result += ".".concat(part);
      } else {
        result = part;
      }
    });
    return result;
  }

  throw new TypeError(pathError());
};
var parsePath = function parsePath(path) {
  if (Array.isArray(path)) {
    return path;
  }

  if (typeof path === 'string') {
    return path.split('.').reduce(function (result, part) {
      if (part === '' && result.length === 0) {
        return result;
      }

      var split = part.split('[');
      var key = split[0];
      var rest = split.slice(1);
      return result.concat(key === '' ? [] : [key], rest.map(function (i) {
        var match = /^([0-9]+)\]$/.exec(i);

        if (!match) {
          throw new TypeError(pathSyntaxError(formatPath(result.concat([part]))));
        }

        return parseInt(match[1], 10);
      }));
    }, []);
  }

  throw new TypeError(pathError());
};

var _setWith = function _setWith(value, path, updater) {
  var currentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  if (!Array.isArray(path)) {
    throw pathArrayError();
  }

  if (!path.length) {
    return updater(value);
  }

  var key = path[0];
  var intKey = isInt(key) ? key : null;

  if (intKey === null && typeof key !== 'string') {
    throw new TypeError(pathPartError(currentPath.concat([key]), path.length > 1));
  }

  var nextValue = value !== undefined ? value[key] : undefined;
  var updateResult = path.length === 1 ? updater(nextValue) : _setWith(nextValue, path.slice(1), updater, currentPath.concat[key]);

  if (intKey !== null) {
    if (Array.isArray(value) || value === undefined) {
      if (value && equals(updateResult, value[intKey])) {
        // The correct value is already in place, abort update.
        return value;
      }

      var _result = value ? value.slice(0) : [];

      while (_result.length <= intKey) {
        _result.push(undefined);
      }

      _result.splice(intKey, 1, updateResult);

      return _result;
    }

    throw new TypeError(expectedArrayError(value, currentPath.concat([key]), path.length > 1));
  } else if (Array.isArray(value)) {
    throw new TypeError(expectedPathIntError(currentPath.concat([key]), path.length > 1));
  }

  if (value !== null && value !== undefined && equals(updateResult, value[key])) {
    // The correct value is already in place, abort update.
    return value;
  }

  var result = _extends({}, value);

  result[path[0]] = updateResult;
  return result;
};

var setWith = function setWith(object, path, updater) {
  return _setWith(object, path, updater);
};
var set$1 = function set(object, path, value) {
  return _setWith(object, path, function () {
    return value;
  });
};
var get = function get(value, path) {
  var currentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (!Array.isArray(path)) {
    throw new TypeError(pathArrayError());
  }

  if (!path.length) {
    return value;
  }

  var key = path[0];
  var keyIsInt = isInt(key);
  var valueIsArray = Array.isArray(value);
  var valueIsUndefined = value === undefined;

  if (!keyIsInt && typeof key !== 'string') {
    throw new TypeError(pathPartError(currentPath.concat([key]), path.length > 1));
  }

  if ((keyIsInt || valueIsUndefined) !== (valueIsArray || valueIsUndefined)) {
    throw new TypeError(keyIsInt ? expectedArrayError(value, currentPath.concat([key]), path.length > 1) : expectedPathIntError(currentPath.concat([key]), path.length > 1));
  }

  return get(valueIsUndefined ? undefined : value[key], path.slice(1), currentPath.concat[key]);
};
var matchesDeep = function matchesDeep(value, test) {
  if (test(value)) {
    return true;
  }

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i += 1) {
      if (matchesDeep(value[i], test)) return true;
    }
  }

  if (/^\[object Object\]$/.test(Object.prototype.toString.call(value))) {
    // eslint-disable-next-line no-restricted-syntax
    for (var key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        if (matchesDeep(value[key], test)) {
          return true;
        }
      }
    }
  }

  return false;
};
var hasValue = function hasValue(value) {
  return matchesDeep(value, function (value) {
    return !/^\[object (Object|Array|Undefined)\]$/.test(Object.prototype.toString.call(value));
  });
};
var isEvent = function isEvent(_event) {
  // Duck-type Event and SyntheticEvent instances
  return _event !== null && _typeof(_event) === 'object' && typeof _event.stopPropagation === 'function' && typeof _event.preventDefault === 'function';
};
var castEvent = function castEvent(event) {
  return isEvent(event) ? event : null;
};
var mergeHandlers = function mergeHandlers(h1, h2) {
  return function (eventOrValue) {
    if (h1) {
      h1(eventOrValue);
      var event = castEvent(eventOrValue);

      if (event !== null && event.defaultPrevented) {
        return;
      }
    }

    h2(eventOrValue);
  };
};
var createParseEvent = function createParseEvent(HTMLElementClass) {
  return function (eventOrValue) {
    var event = castEvent(eventOrValue);

    if (!event) {
      return eventOrValue;
    }

    if (event.target instanceof HTMLElementClass) {
      var type = event.target.type;

      if (type === 'checkbox') {
        return !!event.target.checked;
      } // TODO: Parse additional event types: file, multiple-select, etc.


      return event.target.value;
    }

    return undefined;
  };
};
var parseEvent = createParseEvent(HTMLElement);

var SubmitValidationError =
/*#__PURE__*/
function (_ExtendableError) {
  function SubmitValidationError(errors, original) {
    var _this;

    _classCallCheck(this, SubmitValidationError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SubmitValidationError).call(this, 'Submit Validation Failed'));

    if (_typeof(errors) === 'object' && !Array.isArray(errors)) {
      _this.errors = errors;
    } else {
      _this.errors = null;
    }

    _this.original = original;
    return _this;
  }

  _inherits(SubmitValidationError, _ExtendableError);

  return SubmitValidationError;
}(ExtendableError);

var updateWarningState = function updateWarningState(state) {
  var nextState = state;

  if (!hasValue(nextState.warningState)) {
    nextState = set$1(nextState, ['warningState'], null);
  }

  return nextState;
};

var updateErrorState = function updateErrorState(state) {
  var nextState = state;

  if (!hasValue(nextState.errorState)) {
    nextState = set$1(nextState, ['errorState'], null);
  }

  return nextState;
};

var updateSubmitErrorState = function updateSubmitErrorState(state) {
  var nextState = state;

  if (!hasValue(nextState.submitErrorState)) {
    nextState = set$1(nextState, ['submitErrorState'], null);
  }

  return nextState;
};

var runWarn = function runWarn(state, props) {
  var nextState = state;
  var warningState = props.warn(state.valueState) || null;
  nextState = set$1(nextState, ['warningState'], warningState);

  if (nextState.warningState !== state.warningState) {
    nextState = updateWarningState(nextState);
  }

  if (nextState === state) {
    return null;
  }

  return nextState;
};

var runValidate = function runValidate(state, props) {
  var nextState = state;
  var errorState = props.validate(state.valueState) || null;
  nextState = set$1(nextState, ['errorState'], errorState);

  if (nextState.errorState !== state.errorState) {
    nextState = updateErrorState(nextState);
  }

  if (nextState === state) {
    return null;
  }

  return nextState;
};

var updateValue = function updateValue(path, value) {
  return function (state, props) {
    if (path.length < 1) {
      throw new TypeError(emptyPathArrayError());
    }

    var nextState = state;
    nextState = set$1(nextState, ['valueState'].concat(path), value);

    if (nextState === state) {
      return null;
    }

    nextState = runWarn(nextState, props) || nextState;
    nextState = runValidate(nextState, props) || nextState;
    nextState = set$1(nextState, ['submitErrorState'], null);
    return nextState;
  };
};

var updateInitialValue = function updateInitialValue(path, value) {
  return function (state) {
    if (path.length < 1) {
      throw new TypeError(emptyPathArrayError());
    }

    var nextState = state;
    nextState = set$1(nextState, ['initialValueState'].concat(path), value);

    if (nextState === state) {
      return null;
    }

    return nextState;
  };
};

var updatePendingValue = function updatePendingValue(path, value) {
  return function (state) {
    if (path.length < 1) {
      throw new TypeError(emptyPathArrayError());
    }

    var nextState = state;
    nextState = set$1(nextState, ['pendingValueState'].concat(path), value);

    if (nextState === state) {
      return null;
    }

    return nextState;
  };
};

var updateVisited = function updateVisited(key, visited) {
  return function (state) {
    if (key.length < 1) {
      throw new TypeError(emptyPathStringError());
    }

    var nextState = state;

    var updater = function updater(currentVisited) {
      return !!currentVisited === visited ? currentVisited : visited;
    };

    nextState = setWith(nextState, ['visitedMap', key], updater);

    if (nextState === state) {
      return null;
    }

    return nextState;
  };
};

var updateTouched = function updateTouched(key, touched) {
  return function (state) {
    if (key.length < 1) {
      throw new TypeError(emptyPathStringError());
    }

    var nextState = state;

    var updater = function updater(currentTouched) {
      return !!currentTouched === touched ? currentTouched : touched;
    };

    nextState = setWith(nextState, ['touchedMap', key], updater);

    if (nextState === state) {
      return null;
    }

    return nextState;
  };
};

var updateFocused = function updateFocused(key, focused) {
  return function (state) {
    if (key.length < 1) {
      throw new TypeError(emptyPathStringError());
    }

    if (focused) {
      if (state.focusedPath === key) {
        return null;
      }

      return {
        focusedPath: key
      };
    }

    if (state.focusedPath !== key) {
      return null;
    }

    return {
      focusedPath: null
    };
  };
};

var updateSubmit = function updateSubmit(error) {
  return function (state) {
    var nextState = state;
    nextState = set$1(nextState, ['submitting'], false);
    nextState = set$1(nextState, ['submitSucceeded'], !error);
    nextState = set$1(nextState, ['submitFailed'], !!error);
    var submitErrorState;

    if (error && error instanceof SubmitValidationError) {
      submitErrorState = error.errors;
    } else {
      submitErrorState = null;
    }

    nextState = set$1(nextState, ['submitErrorState'], submitErrorState);
    nextState = updateSubmitErrorState(nextState);
    return nextState;
  };
};

var DefaultStateProvider =
/*#__PURE__*/
function (_React$PureComponent) {
  _createClass(DefaultStateProvider, [{
    key: "setValue",
    value: function setValue(path, value) {
      this.setState(updateValue(parsePath(path), value));
    }
  }, {
    key: "setInitialValue",
    value: function setInitialValue(path, value) {
      this.setState(updateInitialValue(parsePath(path), value));
    }
  }, {
    key: "setPendingValue",
    value: function setPendingValue(path, value) {
      this.setState(updatePendingValue(parsePath(path), value));
    }
  }, {
    key: "setVisited",
    value: function setVisited(path, visited) {
      this.setState(updateVisited(formatPath(path), visited));
    }
  }, {
    key: "setTouched",
    value: function setTouched(path, touched) {
      this.setState(updateTouched(formatPath(path), touched));
    }
  }, {
    key: "setFocused",
    value: function setFocused(path, focused) {
      this.setState(updateFocused(formatPath(path), focused));
    }
  }, {
    key: "submit",
    value: function submit(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      var promise;

      var setState = function setState(update) {
        return new Promise(function (resolve) {
          return _this2._willUnmount ? resolve() : _this2.setState(update, resolve);
        });
      };

      setState(function (state, props) {
        if (state.submitting) {
          promise = Promise.reject(new Error('Form submit blocked pending current submit resolution.'));
          return null;
        }

        if (state.errorState !== null) {
          promise = Promise.reject(new SubmitValidationError(state.errorState));
          return null;
        }

        promise = Promise.resolve(state.valueState).then(props.onSubmit);
        return set$1(state, ['submitting'], true);
      }).then(function () {
        promise.then(function (result) {
          return setState(updateSubmit()).then(function () {
            return _this2.props.onSubmitSuccess(result);
          });
        }, function (error) {
          return setState(updateSubmit(error)).then(function () {
            return error instanceof SubmitValidationError ? _this2.props.onSubmitValidationFail(error) : _this2.props.onSubmitFail(error);
          });
        });
      });
    }
  }, {
    key: "getInitialState",
    value: function getInitialState() {
      var state = {
        initialValueState: this.props.values,
        valueState: this.props.values,
        pendingValueState: this.props.values,
        warningState: null,
        errorState: null,
        submitErrorState: null,
        focusedPath: null,
        touchedMap: {},
        visitedMap: {},
        submitting: false,
        submitFailed: false,
        submitSucceeded: false,
        actions: {
          setValue: this.setValue.bind(this),
          setInitialValue: this.setInitialValue.bind(this),
          setPendingValue: this.setPendingValue.bind(this),
          setTouched: this.setTouched.bind(this),
          setVisited: this.setVisited.bind(this),
          setFocused: this.setFocused.bind(this),
          submit: this.submit.bind(this)
        },
        // Cache prop values for comparison in getDerivedStateFromProps
        _props: {
          warn: this.props.warn,
          validate: this.props.validate
        }
      };
      state = runValidate(state, this.props) || state;
      state = runWarn(state, this.props) || state;
      return state;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._willUnmount = true;
    }
  }]);

  function DefaultStateProvider(props) {
    var _this;

    _classCallCheck(this, DefaultStateProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultStateProvider).call(this, props));
    _this._willUnmount = false;
    _this.state = _this.getInitialState();
    return _this;
  }

  _createClass(DefaultStateProvider, [{
    key: "render",
    value: function render() {
      var children = this.props.children;
      return children(this.state);
    }
  }]);

  _inherits(DefaultStateProvider, _React$PureComponent);

  return DefaultStateProvider;
}(React.PureComponent);

DefaultStateProvider.defaultProps = {
  values: {},
  onSubmit: function onSubmit() {},
  onSubmitFail: function onSubmitFail(error) {
    return Promise.reject(error);
  },
  onSubmitSuccess: function onSubmitSuccess() {},
  onSubmitValidationFail: function onSubmitValidationFail() {},
  warn: function warn() {
    return null;
  },
  validate: function validate() {
    return null;
  }
};

DefaultStateProvider.getDerivedStateFromProps = function (props, state) {
  var nextState = state;
  nextState = set$1(nextState, ['pendingValueState'], props.values);

  if (props.validate !== state._props.validate) {
    nextState = set$1(nextState, ['_props', 'validate'], props.validate);
    nextState = runValidate(nextState, props) || nextState;
  }

  if (props.warn !== state._props.warn) {
    nextState = set$1(nextState, ['_props', 'warn'], props.warn);
    nextState = runWarn(nextState, props) || nextState;
  }

  if (nextState === state) {
    return null;
  }

  return nextState;
};

function defaultStateProviderProp(config, render) {
  return React.createElement(DefaultStateProvider, config, render);
}

var FormWrapper =
/*#__PURE__*/
function (_React$PureComponent) {
  function FormWrapper() {
    _classCallCheck(this, FormWrapper);

    return _possibleConstructorReturn(this, _getPrototypeOf(FormWrapper).apply(this, arguments));
  }

  _createClass(FormWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children(_extends({}, this.props.actions, {
        submitting: this.props.submitting,
        submitFailed: this.props.submitFailed,
        submitSucceeded: this.props.submitSucceeded,
        hasErrors: this.props.hasErrors,
        hasSubmitErrors: this.props.hasSubmitErrors,
        hasWarnings: this.props.hasWarnings
      }));
    }
  }]);

  _inherits(FormWrapper, _React$PureComponent);

  return FormWrapper;
}(React.PureComponent);

var Form =
/*#__PURE__*/
function (_React$PureComponent2) {
  function Form() {
    _classCallCheck(this, Form);

    return _possibleConstructorReturn(this, _getPrototypeOf(Form).apply(this, arguments));
  }

  _createClass(Form, [{
    key: "render",
    value: function render() {
      var _this = this;

      return this.props.stateProvider(this.props, function (context) {
        if (_this._lastSetActions !== context.actions) {
          _extends(_this, context.actions);

          _this._lastSetActions = context.actions;
        }

        return React.createElement(Provider, {
          value: context
        }, React.createElement(FormWrapper, {
          actions: context.actions,
          submitting: context.submitting,
          submitFailed: context.submitFailed,
          submitSucceeded: context.submitSucceeded,
          hasErrors: context.errorState !== null,
          hasSubmitErrors: context.submitErrorState !== null,
          hasWarnings: context.warningState !== null
        }, _this.props.children));
      });
    }
  }]);

  _inherits(Form, _React$PureComponent2);

  return Form;
}(React.PureComponent);

Form.defaultProps = {
  stateProvider: defaultStateProviderProp
};

var renderWrapper = function renderWrapper(Wrapper, context, props) {
  var parsedPath = parsePath(props.path);
  var formattedPath = formatPath(props.path);
  var initialValueState = context.initialValueState,
      valueState = context.valueState,
      pendingValueState = context.pendingValueState,
      warningState = context.warningState,
      errorState = context.errorState,
      submitErrorState = context.submitErrorState,
      focusedPath = context.focusedPath,
      touchedMap = context.touchedMap,
      visitedMap = context.visitedMap,
      submitting = context.submitting,
      submitFailed = context.submitFailed,
      submitSucceeded = context.submitSucceeded,
      actions = context.actions;
  var warning = warningState !== null ? get(warningState, parsedPath) : undefined;
  var error = submitErrorState !== null ? get(submitErrorState, parsedPath) : undefined;

  if ((error === undefined || error === null) && errorState !== null) {
    error = get(errorState, parsedPath);
  }

  return React.createElement(Wrapper, _extends({}, props, {
    initialValue: get(initialValueState, parsedPath),
    value: get(valueState, parsedPath),
    pendingValue: get(pendingValueState, parsedPath),
    warning: warning,
    error: error,
    focused: focusedPath === formattedPath,
    touched: !!touchedMap[formattedPath],
    visited: !!visitedMap[formattedPath],
    submitting: submitting,
    submitFailed: submitFailed,
    submitSucceeded: submitSucceeded
  }, actions));
};

var FieldWrapper =
/*#__PURE__*/
function (_React$PureComponent) {
  function FieldWrapper() {
    _classCallCheck(this, FieldWrapper);

    return _possibleConstructorReturn(this, _getPrototypeOf(FieldWrapper).apply(this, arguments));
  }

  _createClass(FieldWrapper, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          path = _this$props.path,
          format = _this$props.format,
          parse = _this$props.parse,
          compare = _this$props.compare,
          checkbox = _this$props.checkbox,
          initialValue = _this$props.initialValue,
          value = _this$props.value,
          pendingValue = _this$props.pendingValue,
          error = _this$props.error,
          warning = _this$props.warning,
          focused = _this$props.focused,
          touched = _this$props.touched,
          visited = _this$props.visited,
          submitting = _this$props.submitting,
          submitFailed = _this$props.submitFailed,
          submitSucceeded = _this$props.submitSucceeded,
          setFocused = _this$props.setFocused,
          setVisited = _this$props.setVisited,
          setTouched = _this$props.setTouched,
          setValue = _this$props.setValue,
          setInitialValue = _this$props.setInitialValue,
          setPendingValue = _this$props.setPendingValue,
          submit = _this$props.submit,
          index = _this$props.index,
          addField = _this$props.addField,
          _removeField = _this$props.removeField,
          children = _this$props.children;
      var parsedPath = parsePath(path);
      var formattedPath = formatPath(path);
      var dirty = !compare(value, initialValue);
      var detached = !compare(value, pendingValue);
      var hasError = hasValue(error);
      var hasWarning = hasValue(warning);

      var focus = function focus(focused) {
        return setFocused(formattedPath, focused);
      };

      var visit = function visit(visited) {
        return setVisited(formattedPath, visited);
      };

      var touch = function touch(touched) {
        return setTouched(formattedPath, touched);
      };

      var change = function change(nextValue) {
        var parsedValue = parse(nextValue, value);

        if (!detached) {
          setPendingValue(parsedPath, parsedValue);
        }

        setValue(parsedPath, parsedValue);
      };

      var input = {
        name: formattedPath,
        value: checkbox ? undefined : format(value),
        checked: checkbox ? !!format(value) : undefined,
        onFocus: function onFocus() {
          focus(true);
          visit(true);
        },
        onBlur: function onBlur() {
          focus(false);
          touch(true);
        },
        onChange: function onChange(eventOrValue) {
          change(parseEvent(eventOrValue));
        }
      };

      var composeInput = function composeInput(userProps) {
        return _extends({}, userProps, input, {
          onFocus: mergeHandlers(userProps.onFocus, input.onFocus),
          onBlur: mergeHandlers(userProps.onBlur, input.onBlur),
          onChange: mergeHandlers(userProps.onChange, input.onChange)
        });
      };

      var arrayActions;

      if (addField && _removeField && typeof index === 'number') {
        arrayActions = {
          addFieldBefore: function addFieldBefore(value) {
            addField(index, value);
          },
          addFieldAfter: function addFieldAfter(value) {
            addField(index + 1, value);
          },
          removeField: function removeField() {
            _removeField(index);
          }
        };
      }

      return children(_extends({
        // Input Tag Props
        input: input,
        composeInput: composeInput,
        // "Meta" Props
        path: formattedPath,
        hasError: hasError,
        error: error,
        hasWarning: hasWarning,
        warning: warning,
        focused: focused,
        touched: touched,
        visited: visited,
        dirty: dirty,
        pristine: !dirty,
        submitting: submitting,
        submitFailed: submitFailed,
        submitSucceeded: submitSucceeded,
        initialValue: initialValue,
        rawValue: value,
        pendingValue: pendingValue,
        detached: detached,
        // Context Actions
        setFocused: focus,
        setVisited: visit,
        setTouched: touch,
        setValue: change,
        acceptPendingValue: function acceptPendingValue() {
          setValue(parsedPath, pendingValue);
          setInitialValue(parsedPath, pendingValue);
        },
        rejectPendingValue: function rejectPendingValue() {
          setPendingValue(parsedPath, value);
          setInitialValue(parsedPath, pendingValue);
        },
        submit: submit,
        addFieldBefore: undefined,
        addFieldAfter: undefined,
        removeField: undefined
      }, arrayActions));
    }
  }]);

  _inherits(FieldWrapper, _React$PureComponent);

  return FieldWrapper;
}(React.PureComponent);

var Field =
/*#__PURE__*/
function (_React$PureComponent2) {
  function Field() {
    _classCallCheck(this, Field);

    return _possibleConstructorReturn(this, _getPrototypeOf(Field).apply(this, arguments));
  }

  _createClass(Field, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          path = _this$props2.path,
          format = _this$props2.format,
          parse = _this$props2.parse,
          compare = _this$props2.compare,
          checkbox = _this$props2.checkbox,
          children = _this$props2.children;
      return React.createElement(Consumer, null, function (context) {
        return context !== null && renderWrapper(FieldWrapper, context, {
          path: path,
          format: format,
          parse: parse,
          compare: compare,
          checkbox: checkbox,
          children: children
        });
      });
    }
  }]);

  _inherits(Field, _React$PureComponent2);

  return Field;
}(React.PureComponent);

Field.defaultProps = {
  format: function format(v) {
    if (v === null || v === undefined) {
      return '';
    }

    return v;
  },
  parse: function parse(v) {
    return v;
  },
  compare: function compare(value, otherValue) {
    return value === otherValue;
  },
  checkbox: false
};

var FieldArrayWrapper =
/*#__PURE__*/
function (_React$PureComponent) {
  function FieldArrayWrapper() {
    _classCallCheck(this, FieldArrayWrapper);

    return _possibleConstructorReturn(this, _getPrototypeOf(FieldArrayWrapper).apply(this, arguments));
  }

  _createClass(FieldArrayWrapper, [{
    key: "addField",
    value: function addField(index, fieldValue) {
      var _this$props = this.props,
          values = _this$props.value,
          path = _this$props.path,
          setValue = _this$props.setValue;
      var parsedPath = parsePath(path);

      if (Array.isArray(values)) {
        setValue(parsedPath, insert(values, index, fieldValue));
      }
    }
  }, {
    key: "removeField",
    value: function removeField(index) {
      var _this$props2 = this.props,
          values = _this$props2.value,
          path = _this$props2.path,
          setValue = _this$props2.setValue;
      var parsedPath = parsePath(path);

      if (Array.isArray(values)) {
        setValue(parsedPath, remove(values, index));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props3 = this.props,
          path = _this$props3.path,
          format = _this$props3.format,
          parse = _this$props3.parse,
          checkbox = _this$props3.checkbox,
          initialValues = _this$props3.initialValue,
          values = _this$props3.value,
          pendingValues = _this$props3.pendingValue,
          errors = _this$props3.error,
          warnings = _this$props3.warning,
          submitting = _this$props3.submitting,
          submitFailed = _this$props3.submitFailed,
          submitSucceeded = _this$props3.submitSucceeded,
          submit = _this$props3.submit,
          children = _this$props3.children,
          renderField = _this$props3.renderField,
          getFieldKey = _this$props3.getFieldKey;
      var parsedPath = parsePath(path);
      var formattedPath = formatPath(path);

      if (!Array.isArray(values)) {
        throw new Error("expected array value at ".concat(formattedPath));
      }

      if (!Array.isArray(pendingValues)) {
        throw new Error("expected array pendingValue at ".concat(formattedPath));
      }

      if (!Array.isArray(warnings)) {
        throw new Error("expected array warnings at ".concat(formattedPath));
      }

      if (!Array.isArray(errors)) {
        throw new Error("expected array error at ".concat(formattedPath));
      }

      var fields = values.map(function (value, index) {
        var parsedFieldPath = parsedPath.concat([index]);
        return React.createElement(Field, {
          index: index,
          key: getFieldKey(value, index),
          path: parsedFieldPath,
          format: format,
          parse: parse,
          checkbox: checkbox,
          addField: _this.addField.bind(_this),
          removeField: _this.removeField.bind(_this)
        }, renderField);
      }); // TODO: Calculate dirty/detached state with shallow array equality,
      // potentially with deep equality. Maybe provide a callback to allow the
      // consumer to provide a compare func?

      var hasErrors = hasValue(errors);
      var hasWarnings = hasValue(warnings);
      return children({
        fields: fields,
        // "Meta" Props
        path: formattedPath,
        hasErrors: hasErrors,
        errors: errors,
        hasWarnings: hasWarnings,
        warnings: warnings,
        submitting: submitting,
        submitFailed: submitFailed,
        submitSucceeded: submitSucceeded,
        initialValues: initialValues,
        rawValues: values,
        pendingValues: pendingValues,
        // Context Actions
        submit: submit,
        // FieldArray Actions
        addField: function addField(value) {
          this.addField(fields.length, value);
        }
      });
    }
  }]);

  _inherits(FieldArrayWrapper, _React$PureComponent);

  return FieldArrayWrapper;
}(React.PureComponent);

FieldArrayWrapper.defaultProps = {
  initialValue: [],
  value: [],
  pendingValue: [],
  error: [],
  warning: [],
  submitError: []
};

var FieldArray =
/*#__PURE__*/
function (_React$PureComponent2) {
  function FieldArray() {
    _classCallCheck(this, FieldArray);

    return _possibleConstructorReturn(this, _getPrototypeOf(FieldArray).apply(this, arguments));
  }

  _createClass(FieldArray, [{
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          path = _this$props4.path,
          format = _this$props4.format,
          parse = _this$props4.parse,
          checkbox = _this$props4.checkbox,
          renderField = _this$props4.renderField,
          children = _this$props4.children,
          getFieldKey = _this$props4.getFieldKey;
      return React.createElement(Consumer, null, function (context) {
        return context !== null && renderWrapper(FieldArrayWrapper, context, {
          path: path,
          format: format,
          parse: parse,
          checkbox: checkbox,
          renderField: renderField,
          children: children,
          getFieldKey: getFieldKey
        });
      });
    }
  }]);

  _inherits(FieldArray, _React$PureComponent2);

  return FieldArray;
}(React.PureComponent);

FieldArray.defaultProps = {
  children: function children(_ref) {
    var fields = _ref.fields;
    return fields;
  },
  getFieldKey: function getFieldKey(stateValue, index) {
    return "".concat(index);
  }
};

var withField = function withField(propName, config) {
  return function (Component) {
    if (typeof propName !== 'string') {
      throw new TypeError('Invalid withField prop name. Expected string.');
    }

    if (!config || _typeof(config) !== 'object') {
      throw new TypeError('Invalid withField config. Expected object.');
    }

    if (!isValidPath(config.path)) {
      throw new TypeError(emptyPathError());
    }

    var WithField =
    /*#__PURE__*/
    function (_React$PureComponent) {
      function WithField() {
        _classCallCheck(this, WithField);

        return _possibleConstructorReturn(this, _getPrototypeOf(WithField).apply(this, arguments));
      }

      _createClass(WithField, [{
        key: "render",
        value: function render() {
          var _this = this;

          return React.createElement(Field, config, function (fieldProps) {
            var props = {};
            props[propName] = fieldProps;
            return React.createElement(Component, _extends({}, props, _this.props));
          });
        }
      }]);

      _inherits(WithField, _React$PureComponent);

      return WithField;
    }(React.PureComponent);

    return hoistStatics(WithField, Component);
  };
};

//  strict

exports.default = Form;
exports.Field = Field;
exports.FieldArray = FieldArray;
exports.Form = Form;
exports.SubmitValidationError = SubmitValidationError;
exports.withField = withField;
exports.get = get;
exports.set = set$1;
exports.parsePath = parsePath;
exports.formatPath = formatPath;
//# sourceMappingURL=index.js.map
