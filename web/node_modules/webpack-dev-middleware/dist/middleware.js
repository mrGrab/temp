"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = wrapper;

var _path = _interopRequireDefault(require("path"));

var _mimeTypes = _interopRequireDefault(require("mime-types"));

var _getFilenameFromUrl = _interopRequireDefault(require("./utils/getFilenameFromUrl"));

var _handleRangeHeaders = _interopRequireDefault(require("./utils/handleRangeHeaders"));

var _ready = _interopRequireDefault(require("./utils/ready"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapper(context) {
  return function middleware(req, res, next) {
    // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.
    // eslint-disable-next-line no-param-reassign
    res.locals = res.locals || {};

    function goNext() {
      if (!context.options.serverSideRender) {
        return next();
      }

      return new Promise(resolve => {
        (0, _ready.default)(context, () => {
          // eslint-disable-next-line no-param-reassign
          res.locals.webpack = {
            devMiddleware: context
          };
          resolve(next());
        }, req);
      });
    }

    const acceptedMethods = context.options.methods || ['GET', 'HEAD'];

    if (acceptedMethods.indexOf(req.method) === -1) {
      return goNext();
    }

    return new Promise(resolve => {
      // eslint-disable-next-line consistent-return
      function processRequest() {
        const filename = (0, _getFilenameFromUrl.default)(context, req.url);

        if (!filename) {
          return resolve(goNext());
        }

        let content;

        try {
          content = context.outputFileSystem.readFileSync(filename);
        } catch (_ignoreError) {
          return resolve(goNext());
        }

        content = (0, _handleRangeHeaders.default)(content, req, res);

        if (!res.get('Content-Type')) {
          const contentType = _mimeTypes.default.contentType(_path.default.extname(filename));

          if (contentType) {
            res.set('Content-Type', contentType);
          }
        }

        const {
          headers
        } = context.options;

        if (headers) {
          for (const name in headers) {
            if ({}.hasOwnProperty.call(headers, name)) {
              res.set(name, context.options.headers[name]);
            }
          }
        }

        res.send(content);
        resolve();
      }

      (0, _ready.default)(context, processRequest, req);
    });
  };
}